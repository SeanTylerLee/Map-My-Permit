<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Standard PWA/iOS meta -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Submit Permit • Map My Permit</title>

  <!-- Shared styles -->
  <link rel="stylesheet" href="styles.css" />

  <!-- Mapbox GL JS -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet"/>
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

  <!-- Tesseract.js for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <!-- ===== App Header with Back/Home ===== -->
  <header class="app-header">
    <button class="icon-btn" onclick="history.back()" aria-label="Back">
      <img src="images/back.png" alt="Back" />
    </button>
    <div class="app-title-wrap">
      <h1 class="app-title">Submit Permits</h1>
      <p class="app-subtitle">Upload • Read • Parse • Map</p>
    </div>
    <a class="icon-btn" href="index.html" aria-label="Home">
      <img src="images/home.png" alt="Home" />
    </a>
  </header>

  <!-- ===== Main content ===== -->
  <main class="content">

    <!-- Upload or capture a photo -->
    <section class="card">
      <h2 class="section-title">Upload or Take a Photo</h2>
      <!-- Updated input: allows camera roll and taking photo -->
      <input id="permitImage" type="file" accept="image/*" />
      <div class="preview-wrap">
        <img id="preview" alt="Preview" />
      </div>
      <button id="runOcrBtn" class="primary-btn" disabled>Read Text with AI (OCR)</button>
      <p id="ocrStatus" class="muted small"></p>
    </section>

    <!-- OCR raw text -->
    <section class="card">
      <h2 class="section-title">Detected Text</h2>
      <textarea id="ocrText" class="mono" rows="8" placeholder="OCR results will appear here..." readonly></textarea>
    </section>

    <!-- Parsed steps -->
    <section class="card">
      <h2 class="section-title">Parsed Route Steps</h2>
      <p class="muted small">
        Parser tries Wyoming table format first, then simple START/END with steps.
      </p>
      <textarea id="parsedJson" class="mono" rows="10" readonly></textarea>
      <div class="row">
        <button id="editStepsBtn" class="ghost-btn">Edit Steps Manually</button>
        <button id="buildRouteBtn" class="primary-btn" disabled>Build Map Route</button>
        <button id="saveRouteBtn" class="ghost-btn" disabled>Save Route</button>
      </div>
    </section>

    <!-- Map -->
    <section class="card">
      <h2 class="section-title">Map Preview</h2>
      <div id="map" class="map"></div>
      <div class="chip-row">
        <button id="setStartMode" class="chip">Pick Start on Map</button>
        <button id="setEndMode" class="chip">Pick End on Map</button>
        <button id="addWaypointMode" class="chip">Add Waypoint</button>
        <button id="clearWaypoints" class="chip">Clear</button>
      </div>
    </section>

  </main>

  <!-- Bottom Nav -->
  <nav class="tabbar">
    <a class="tab" href="index.html">
      <img src="images/home.png" alt="" />
      <span>Home</span>
    </a>
    <a class="tab" href="routes.html">
      <img src="images/route.png" alt="" />
      <span>Routes</span>
    </a>
  </nav>

<script>
/* =================== CONFIG =================== */
mapboxgl.accessToken = 'pk.eyJ1Ijoic2VhbmxlZTkyIiwiYSI6ImNtZTAyeG0wbzAwamgybHE2cmwzenJtM2cifQ.DE8FeoDvc3EzuyR5uPopzA';

/* =================== DOM REFS =================== */
const fileInput = document.getElementById('permitImage');
const previewEl = document.getElementById('preview');
const runOcrBtn = document.getElementById('runOcrBtn');
const ocrStatus = document.getElementById('ocrStatus');
const ocrText = document.getElementById('ocrText');
const parsedJson = document.getElementById('parsedJson');
const buildRouteBtn = document.getElementById('buildRouteBtn');
const saveRouteBtn  = document.getElementById('saveRouteBtn');
const editStepsBtn = document.getElementById('editStepsBtn');

/* =================== MAP STATE =================== */
let start = null;
let end = null;
let waypoints = [];
let map, startMarker, endMarker, waypointMarkers = [];
let clickMode = null;
let lastRouteGeoJSON = null;

/* =================== IMAGE PREVIEW =================== */
fileInput.addEventListener('change', () => {
  const file = fileInput.files?.[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  previewEl.src = url;
  runOcrBtn.disabled = false;
  ocrText.value = '';
  parsedJson.value = '';
  ocrStatus.textContent = '';
});

/* =================== OCR =================== */
runOcrBtn.addEventListener('click', async () => {
  const file = fileInput.files?.[0];
  if (!file) return;

  runOcrBtn.disabled = true;
  ocrStatus.textContent = 'Reading text...';
  try {
    const { data } = await Tesseract.recognize(file, 'eng', {
      logger: m => {
        if (m.status && m.progress != null) {
          ocrStatus.textContent = `${m.status} ${Math.round(m.progress * 100)}%`;
        }
      }
    });
    const text = (data?.text || '').trim();
    ocrText.value = text;
    ocrStatus.textContent = 'Done. Parsing...';

    const wy = parseWyomingTable(text);
    const parsed = wy || parseSimpleBullets(text);

    parsedJson.value = JSON.stringify(parsed, null, 2);
    buildRouteBtn.disabled = true;
    saveRouteBtn.disabled = false;
    ocrStatus.textContent = 'Parsed.';
  } catch (e) {
    console.error(e);
    ocrStatus.textContent = 'OCR failed.';
  } finally {
    runOcrBtn.disabled = false;
  }
});

/* =================== SIMPLE PARSER =================== */
function parseSimpleBullets(text) {
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const result = { format: 'simple', start: null, end: null, steps: [] };
  for (const line of lines) {
    if (/^START:/i.test(line)) {
      result.start = line.replace(/^START:/i, '').trim();
    } else if (/^END:/i.test(line)) {
      result.end = line.replace(/^END:/i, '').trim();
    } else if (/^[-•]/.test(line)) {
      result.steps.push({ text: line.replace(/^[-•]\s?/, '').trim() });
    }
  }
  return result;
}

/* =================== WYOMING TABLE PARSER =================== */
function parseWyomingTable(text) {
  if (!/Final Destination:/i.test(text)) return null;
  const result = { format: 'wy_permit', origin: null, destination: null, rows: [] };
  const originMatch = text.match(/Origin:\s*(.+)/i);
  if (originMatch) result.origin = originMatch[1].trim();
  const destMatch = text.match(/Final Destination:\s*(.+)/i);
  if (destMatch) result.destination = destMatch[1].trim();

  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const headerIdx = lines.findIndex(l => /Miles/i.test(l) && /Route/i.test(l) && /Directions/i.test(l));
  if (headerIdx === -1) return result;

  for (let i = headerIdx + 1; i < lines.length; i++) {
    const line = lines[i];
    if (/Final Destination/i.test(line)) break;
    const milesMatch = line.match(/^(\d+(\.\d+)?)/);
    if (!milesMatch) continue;
    const miles = parseFloat(milesMatch[1]);
    const rest = line.replace(/^(\d+(\.\d+)?)/, '').trim();
    const parts = rest.split(/\s{2,}/);
    let route = '', directions = '';
    if (parts.length >= 2) {
      route = parts[0].trim();
      directions = parts.slice(1).join('  ').trim();
    } else {
      const soft = rest.split(/\s+/);
      route = soft.shift() || '';
      directions = soft.join(' ');
    }
    result.rows.push({ miles, route, directions });
  }
  return result;
}

/* =================== MAP INIT =================== */
map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/streets-v12',
  center: [-104.99, 41.14],
  zoom: 6
});
map.addControl(new mapboxgl.NavigationControl(), 'top-right');

map.on('click', (e) => {
  const lngLat = e.lngLat;
  if (clickMode === 'start') {
    start = lngLat; addOrMoveMarker('start', lngLat);
  } else if (clickMode === 'end') {
    end = lngLat; addOrMoveMarker('end', lngLat);
  } else if (clickMode === 'waypoint') {
    waypoints.push(lngLat); addOrMoveMarker('waypoint', lngLat);
  }
});

/* =================== MAP CONTROLS =================== */
document.getElementById('setStartMode').onclick = () => clickMode = 'start';
document.getElementById('setEndMode').onclick = () => clickMode = 'end';
document.getElementById('addWaypointMode').onclick = () => clickMode = 'waypoint';
document.getElementById('clearWaypoints').onclick = () => {
  waypoints = [];
  waypointMarkers.forEach(m => m.remove());
  waypointMarkers = [];
  removeRouteLayer();
};

buildRouteBtn.addEventListener('click', async () => {
  if (!start || !end) {
    alert('Set start and end on the map first.');
    return;
  }
  await drawRoute(start, end, waypoints);
  saveRouteBtn.disabled = !lastRouteGeoJSON;
});

editStepsBtn.addEventListener('click', () => {
  parsedJson.removeAttribute('readonly');
  parsedJson.focus();
});

/* =================== SAVE ROUTE =================== */
saveRouteBtn.addEventListener('click', () => {
  try {
    const name = prompt('Name this route:', 'Wy Permit Route') || 'Untitled Route';
    const record = {
      id: 'r_' + Math.random().toString(36).slice(2),
      name,
      createdAt: new Date().toISOString(),
      start, end, waypoints,
      route: lastRouteGeoJSON,
      ocrText: ocrText.value,
      parsed: JSON.parse(parsedJson.value || '{}')
    };
    const KEY = 'mmp_routes';
    const list = JSON.parse(localStorage.getItem(KEY) || '[]');
    list.unshift(record);
    localStorage.setItem(KEY, JSON.stringify(list));
    alert('Saved! View it in Routes.');
  } catch (e) {
    console.error(e);
    alert('Could not save route.');
  }
});

/* =================== MAP HELPERS =================== */
function addOrMoveMarker(kind, lngLat) {
  if (kind === 'start') {
    if (!startMarker) startMarker = new mapboxgl.Marker({ color: '#2ecc71' });
    startMarker.setLngLat(lngLat).addTo(map);
  } else if (kind === 'end') {
    if (!endMarker) endMarker = new mapboxgl.Marker({ color: '#e74c3c' });
    endMarker.setLngLat(lngLat).addTo(map);
  } else if (kind === 'waypoint') {
    const m = new mapboxgl.Marker();
    m.setLngLat(lngLat).addTo(map);
    waypointMarkers.push(m);
  }
}

function removeRouteLayer() {
  if (map.getSource('route')) {
    map.removeLayer('route');
    map.removeSource('route');
  }
  lastRouteGeoJSON = null;
  saveRouteBtn.disabled = true;
}

/* =================== DRAW ROUTE =================== */
async function drawRoute(start, end, wps = []) {
  removeRouteLayer();
  const all = [start, ...wps, end]
    .map(p => `${p.lng.toFixed(6)},${p.lat.toFixed(6)}`)
    .join(';');
  const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${all}?geometries=geojson&overview=full&access_token=${mapboxgl.accessToken}`;
  const res = await fetch(url);
  const json = await res.json();
  const route = json?.routes?.[0]?.geometry;
  if (!route) {
    alert('No route found.');
    return;
  }
  lastRouteGeoJSON = { type: 'Feature', properties: {}, geometry: route };
  map.addSource('route', { type: 'geojson', data: lastRouteGeoJSON });
  map.addLayer({
    id: 'route',
    type: 'line',
    source: 'route',
    paint: { 'line-width': 5, 'line-color': '#111' }
  });
  const bounds = new mapboxgl.LngLatBounds();
  route.coordinates.forEach(c => bounds.extend(c));
  map.fitBounds(bounds, { padding: 30 });
}
</script>
</body>
</html>