<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Standard PWA/iOS meta -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Submit Permit • Map My Permit</title>

  <!-- Shared styles -->
  <link rel="stylesheet" href="styles.css" />

  <!-- Mapbox GL JS (maps) -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet"/>
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

  <!-- Tesseract.js (client-side OCR) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <!-- ===== App Header with Back/Home ===== -->
  <header class="app-header">
    <button class="icon-btn" onclick="history.back()" aria-label="Back">
      <img src="images/back.png" alt="Back" />
    </button>
    <div class="app-title-wrap">
      <h1 class="app-title">Submit Permits</h1>
      <p class="app-subtitle">Upload • Read • Parse • Map</p>
    </div>
    <a class="icon-btn" href="index.html" aria-label="Home">
      <img src="images/home.png" alt="Home" />
    </a>
  </header>

  <!-- ===== Main content ===== -->
  <main class="content">

    <!-- 1) Upload / capture -->
    <section class="card">
      <h2 class="section-title">Upload or Take a Photo</h2>
      <!-- Allows Camera and Photo Library on iOS -->
      <input id="permitImage" type="file" accept="image/*" />
      <div class="preview-wrap">
        <img id="preview" alt="Preview" />
      </div>
      <!-- You won’t need to press this (we auto-run), but it stays as a manual retry -->
      <button id="runOcrBtn" class="primary-btn" disabled>Read Text with AI (OCR)</button>
      <p id="ocrStatus" class="muted small"></p>
    </section>

    <!-- 2) Raw OCR text (read-only for transparency) -->
    <section class="card">
      <h2 class="section-title">Detected Text</h2>
      <textarea id="ocrText" class="mono" rows="8" placeholder="OCR results will appear here..." readonly></textarea>
    </section>

    <!-- 3) Parsed permit (editable JSON if you ever need to tweak) -->
    <section class="card">
      <h2 class="section-title">Parsed Route Steps</h2>
      <p class="muted small">
        AI tries Wyoming table format first, then a simple START/END fallback.
        After parsing, we auto-geocode Start/End and map the route with turn-by-turn steps.
      </p>
      <textarea id="parsedJson" class="mono" rows="10" readonly></textarea>
      <div class="row">
        <button id="editStepsBtn" class="ghost-btn">Edit Steps Manually</button>
        <button id="buildRouteBtn" class="primary-btn" disabled>Build Map Route</button>
        <button id="saveRouteBtn" class="ghost-btn" disabled>Save Route</button>
      </div>
    </section>

    <!-- 4) Map + Turn-by-turn (auto-populated) -->
    <section class="card">
      <h2 class="section-title">Map Preview</h2>
      <div id="map" class="map"></div>
      <div id="turnByTurn" style="margin-top:10px;">
        <h3 class="section-title" style="margin-top:10px;">Turn-by-Turn</h3>
        <ol id="turnList" class="small" style="padding-left:18px;"></ol>
      </div>

      <!-- (Optional) manual point tools still here if you want to adjust -->
      <div class="chip-row">
        <button id="setStartMode" class="chip">Pick Start on Map</button>
        <button id="setEndMode" class="chip">Pick End on Map</button>
        <button id="addWaypointMode" class="chip">Add Waypoint</button>
        <button id="clearWaypoints" class="chip">Clear</button>
      </div>
    </section>

  </main>

  <!-- Bottom Nav -->
  <nav class="tabbar">
    <a class="tab" href="index.html">
      <img src="images/home.png" alt="" />
      <span>Home</span>
    </a>
    <a class="tab" href="settings.html">
      <img src="images/settings.png" alt="" />
      <span>Routes</span>
    </a>
  </nav>

<script>
/* ============================================================
   0) CONFIG: Mapbox token
   ============================================================ */
mapboxgl.accessToken = 'pk.eyJ1Ijoic2VhbmxlZTkyIiwiYSI6ImNtZTAyeG0wbzAwamgybHE2cmwzenJtM2cifQ.DE8FeoDvc3EzuyR5uPopzA';

/* ============================================================
   1) DOM references
   ============================================================ */
const fileInput = document.getElementById('permitImage');
const previewEl = document.getElementById('preview');
const runOcrBtn = document.getElementById('runOcrBtn');
const ocrStatus = document.getElementById('ocrStatus');
const ocrText = document.getElementById('ocrText');
const parsedJson = document.getElementById('parsedJson');
const buildRouteBtn = document.getElementById('buildRouteBtn');
const saveRouteBtn  = document.getElementById('saveRouteBtn');
const editStepsBtn  = document.getElementById('editStepsBtn');
const turnList = document.getElementById('turnList');

/* ============================================================
   2) Map state + init
   ============================================================ */
let start = null;        // {lng, lat}
let end = null;          // {lng, lat}
let waypoints = [];      // [{lng, lat}]
let map, startMarker, endMarker, waypointMarkers = [];
let clickMode = null;    // 'start' | 'end' | 'waypoint' | null
let lastRouteGeoJSON = null;

map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/streets-v12',
  center: [-104.99, 41.14], // WY-ish default
  zoom: 6
});
map.addControl(new mapboxgl.NavigationControl(), 'top-right');

/* Let users still manually set points, if desired */
map.on('click', (e) => {
  const lngLat = e.lngLat;
  if (clickMode === 'start') {
    start = lngLat; addOrMoveMarker('start', lngLat);
  } else if (clickMode === 'end') {
    end = lngLat; addOrMoveMarker('end', lngLat);
  } else if (clickMode === 'waypoint') {
    waypoints.push(lngLat); addOrMoveMarker('waypoint', lngLat);
  }
});
document.getElementById('setStartMode').onclick = () => clickMode = 'start';
document.getElementById('setEndMode').onclick   = () => clickMode = 'end';
document.getElementById('addWaypointMode').onclick = () => clickMode = 'waypoint';
document.getElementById('clearWaypoints').onclick = () => {
  waypoints = [];
  waypointMarkers.forEach(m => m.remove());
  waypointMarkers = [];
  removeRouteLayer();
  turnList.innerHTML = '';
};

/* ============================================================
   3) AUTO FLOW: when a file is chosen → OCR → Parse → Geocode → Route
   ============================================================ */
fileInput.addEventListener('change', async () => {
  const file = fileInput.files?.[0];
  if (!file) return;

  // Show a quick preview
  const url = URL.createObjectURL(file);
  previewEl.src = url;

  // Run the whole pipeline automatically
  await processImageToRoute(file);
});

/* Keep the manual button as a fallback */
runOcrBtn.addEventListener('click', async () => {
  const file = fileInput.files?.[0];
  if (!file) return;
  await processImageToRoute(file);
});

/* Main pipeline runner */
async function processImageToRoute(file) {
  try {
    runOcrBtn.disabled = true;
    ocrStatus.textContent = 'Reading text...';

    // --- OCR ---
    const { data } = await Tesseract.recognize(file, 'eng', {
      logger: m => {
        if (m.status && m.progress != null) {
          ocrStatus.textContent = `${m.status} ${Math.round(m.progress * 100)}%`;
        }
      }
    });
    const text = (data?.text || '').trim();
    ocrText.value = text;

    // --- Parse (Wyoming first, then simple) ---
    ocrStatus.textContent = 'Parsing permit...';
    const wy = parseWyomingTable(text);
    const parsed = wy || parseSimpleBullets(text);
    parsedJson.value = JSON.stringify(parsed, null, 2);

    // --- Geocode Start/End from parsed data ---
    ocrStatus.textContent = 'Finding start/end...';
    const startLabel = (parsed.origin || parsed.start || parsed.startText || '').trim();
    const endLabel   = (parsed.destination || parsed.end || parsed.endText || '').trim();

    if (!startLabel || !endLabel) {
      ocrStatus.textContent = 'Could not find clear start/end in permit. You can set them on the map.';
      buildRouteBtn.disabled = !(start && end);
      saveRouteBtn.disabled = true;
      return;
    }

    const startCoord = await geocodeToLngLat(startLabel);
    const endCoord   = await geocodeToLngLat(endLabel);

    if (!startCoord || !endCoord) {
      ocrStatus.textContent = 'Geocoding failed. Try editing the parsed JSON Start/End text.';
      return;
    }

    // Update map markers
    start = startCoord; addOrMoveMarker('start', start);
    end   = endCoord;   addOrMoveMarker('end',   end);

    // --- Build & draw route (auto) + steps ---
    ocrStatus.textContent = 'Building route...';
    await drawRouteWithSteps(start, end, waypoints);

    // Enable Save now that we have a route line
    saveRouteBtn.disabled = !lastRouteGeoJSON;
    buildRouteBtn.disabled = false;
    ocrStatus.textContent = 'Done.';
  } catch (e) {
    console.error(e);
    ocrStatus.textContent = 'Something went wrong. Try a clearer photo.';
  } finally {
    runOcrBtn.disabled = false;
  }
}

/* ============================================================
   4) Parsers (Wy permit table + simple bullets)
   ============================================================ */
function parseSimpleBullets(text) {
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const result = { format: 'simple', start: null, end: null, steps: [] };
  for (const line of lines) {
    if (/^START:/i.test(line)) {
      result.start = line.replace(/^START:/i, '').trim();
    } else if (/^END:/i.test(line)) {
      result.end = line.replace(/^END:/i, '').trim();
    } else if (/^[-•]/.test(line)) {
      result.steps.push({ text: line.replace(/^[-•]\s?/, '').trim() });
    } else if (/^Origin:/i.test(line)) {
      result.start = line.replace(/^Origin:/i, '').trim();
    } else if (/^Final Destination:/i.test(line)) {
      result.end = line.replace(/^Final Destination:/i, '').trim();
    }
  }
  return result;
}

function parseWyomingTable(text) {
  if (!/Final Destination:/i.test(text)) return null;
  const result = { format: 'wy_permit', origin: null, destination: null, rows: [] };
  const originMatch = text.match(/Origin:\s*(.+)/i);
  if (originMatch) result.origin = originMatch[1].trim();
  const destMatch = text.match(/Final Destination:\s*(.+)/i);
  if (destMatch) result.destination = destMatch[1].trim();

  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const headerIdx = lines.findIndex(l => /Miles/i.test(l) && /Route/i.test(l) && /Directions/i.test(l));
  if (headerIdx === -1) return result;

  for (let i = headerIdx + 1; i < lines.length; i++) {
    const line = lines[i];
    if (/Final Destination/i.test(line)) break;

    // Many WY rows begin with miles
    const milesMatch = line.match(/^(\d+(\.\d+)?)/);
    if (!milesMatch) continue;

    const miles = parseFloat(milesMatch[1]);
    const rest = line.replace(/^(\d+(\.\d+)?)/, '').trim();

    // Heuristic split for "ROUTE   DIRECTIONS"
    const parts = rest.split(/\s{2,}/);
    let route = '', directions = '';
    if (parts.length >= 2) {
      route = parts[0].trim();
      directions = parts.slice(1).join('  ').trim();
    } else {
      const soft = rest.split(/\s+/);
      route = soft.shift() || '';
      directions = soft.join(' ');
    }

    result.rows.push({ miles, route, directions });
  }
  return result;
}

/* ============================================================
   5) Geocoding helpers (Mapbox Geocoding API)
   ============================================================ */
async function geocodeToLngLat(query) {
  // Encode and look up one best match (US bias)
  const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?limit=1&country=US&access_token=${mapboxgl.accessToken}`;
  try {
    const res = await fetch(url);
    const json = await res.json();
    const feat = json?.features?.[0];
    if (!feat || !feat.center) return null;
    return { lng: feat.center[0], lat: feat.center[1] };
  } catch {
    return null;
  }
}

/* ============================================================
   6) Map helpers (markers, layers)
   ============================================================ */
function addOrMoveMarker(kind, lngLat) {
  if (kind === 'start') {
    if (!startMarker) startMarker = new mapboxgl.Marker({ color: '#2ecc71' });
    startMarker.setLngLat(lngLat).addTo(map);
  } else if (kind === 'end') {
    if (!endMarker) endMarker = new mapboxgl.Marker({ color: '#e74c3c' });
    endMarker.setLngLat(lngLat).addTo(map);
  } else if (kind === 'waypoint') {
    const m = new mapboxgl.Marker();
    m.setLngLat(lngLat).addTo(map);
    waypointMarkers.push(m);
  }
}

function removeRouteLayer() {
  if (map.getSource('route')) {
    map.removeLayer('route');
    map.removeSource('route');
  }
  lastRouteGeoJSON = null;
  turnList.innerHTML = '';
}

/* ============================================================
   7) Build route + show turn-by-turn
   ============================================================ */
buildRouteBtn.addEventListener('click', async () => {
  if (!start || !end) {
    alert('Set start and end first (tap map or edit parsed start/end).');
    return;
  }
  await drawRouteWithSteps(start, end, waypoints);
  saveRouteBtn.disabled = !lastRouteGeoJSON;
});

/* Draw route and list steps using Mapbox Directions API */
async function drawRouteWithSteps(start, end, wps = []) {
  removeRouteLayer();

  const all = [start, ...(wps || []), end]
    .map(p => `${p.lng.toFixed(6)},${p.lat.toFixed(6)}`)
    .join(';');

  // Ask for step-by-step instructions
  const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${all}?geometries=geojson&overview=full&steps=true&access_token=${mapboxgl.accessToken}`;

  const res = await fetch(url);
  const json = await res.json();
  const route = json?.routes?.[0];
  const geom = route?.geometry;

  if (!geom) {
    alert('No route found. Try adjusting points or clarifying start/end.');
    return;
  }

  // Draw line
  lastRouteGeoJSON = { type: 'Feature', properties: {}, geometry: geom };
  map.addSource('route', { type: 'geojson', data: lastRouteGeoJSON });
  map.addLayer({
    id: 'route',
    type: 'line',
    source: 'route',
    paint: { 'line-width': 5, 'line-color': '#111' }
  });

  // Fit to route
  const bounds = new mapboxgl.LngLatBounds();
  geom.coordinates.forEach(c => bounds.extend(c));
  map.fitBounds(bounds, { padding: 30 });

  // Turn-by-turn list from first leg
  renderTurnByTurn(route.legs?.[0]?.steps || []);
}

/* Render a simple ordered list of step instructions */
function renderTurnByTurn(steps) {
  turnList.innerHTML = '';
  steps.forEach((s, i) => {
    const li = document.createElement('li');
    li.textContent = s.maneuver?.instruction || `Step ${i+1}`;
    turnList.appendChild(li);
  });
}

/* ============================================================
   8) Edit parsed JSON (power users)
   ============================================================ */
editStepsBtn.addEventListener('click', () => {
  const ro = parsedJson.hasAttribute('readonly');
  if (ro) {
    parsedJson.removeAttribute('readonly');
    parsedJson.focus();
    editStepsBtn.textContent = 'Lock JSON';
  } else {
    parsedJson.setAttribute('readonly', 'readonly');
    editStepsBtn.textContent = 'Edit Steps Manually';
  }
});

/* ============================================================
   9) Save route to localStorage (for routes.html)
   ============================================================ */
saveRouteBtn.addEventListener('click', () => {
  try {
    const name = prompt('Name this route:', 'Permit Route') || 'Untitled Route';
    const record = {
      id: 'r_' + Math.random().toString(36).slice(2),
      name,
      createdAt: new Date().toISOString(),
      start, end, waypoints,
      route: lastRouteGeoJSON,
      ocrText: ocrText.value,
      parsed: JSON.parse(parsedJson.value || '{}')
    };
    const KEY = 'mmp_routes';
    const list = JSON.parse(localStorage.getItem(KEY) || '[]');
    list.unshift(record);
    localStorage.setItem(KEY, JSON.stringify(list));
    alert('Saved! View it in Routes.');
  } catch (e) {
    console.error(e);
    alert('Could not save route.');
  }
});
</script>
</body>
</html>