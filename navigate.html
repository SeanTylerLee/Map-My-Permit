<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Navigate</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" href="styles.css" />

  <!-- Mapbox & Leaflet -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- Turf.js for distance calculations -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
</head>
<body>
  <header>Map My Permit: Navigation</header>

  <main>
    <div id="map" style="height: calc(100vh - 150px);"></div>
    <div id="status" style="padding: 10px;">Initializing...</div>
  </main>

  <nav class="bottom-nav">
    <button onclick="history.back()">üîô Back</button>
    <button onclick="location.href='index.html'">üè† Home</button>
    <button onclick="location.href='settings.html'">‚öôÔ∏è Settings</button>
  </nav>

  <script>
    const mapboxToken = 'pk.eyJ1Ijoic2VhbmxlZTkyIiwiYSI6ImNtZTAyeG0wbzAwamgybHE2cmwzenJtM2cifQ.DE8FeoDvc3EzuyR5uPopzA';

    // Initialize Leaflet map
    const map = L.map('map').setView([43.0, -105.5], 7);
    L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=${mapboxToken}`, {
      tileSize: 512,
      zoomOffset: -1,
      attribution: '¬© Mapbox ¬© OpenStreetMap'
    }).addTo(map);

    const statusDiv = document.getElementById('status');

    // Load start/end points and parsed steps
    const start = JSON.parse(localStorage.getItem("manualStart"));
    const end = JSON.parse(localStorage.getItem("manualEnd"));
    const steps = JSON.parse(localStorage.getItem("parsedRoute") || "[]");

    if (!start || !end || steps.length === 0) {
      statusDiv.innerText = "Missing start/end or parsed steps. Return and try again.";
      throw new Error("Required data not found.");
    }

    // Geocode each step to get coordinates
    async function geocodeStep(step) {
      const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(step)}.json?access_token=${mapboxToken}&limit=1`;
      const res = await fetch(url);
      const data = await res.json();
      if (data.features && data.features.length > 0) {
        return data.features[0].center.reverse(); // [lat, lng]
      }
      return null;
    }

    async function buildFullRoute() {
      statusDiv.innerText = "Building route...";
      const waypointCoords = [];

      for (const step of steps) {
        const coords = await geocodeStep(step);
        if (coords) waypointCoords.push(coords);
      }

      const fullRoute = [start, ...waypointCoords, end];
      const coordString = fullRoute.map(p => `${p[1]},${p[0]}`).join(';');

      const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${coordString}?geometries=geojson&access_token=${mapboxToken}`;
      const res = await fetch(url);
      const data = await res.json();

      if (!data.routes || !data.routes[0]) {
        statusDiv.innerText = "Mapbox couldn't build route.";
        return;
      }

      const route = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
      const polyline = L.polyline(route, { color: 'blue' }).addTo(map);
      map.fitBounds(polyline.getBounds());

      // Start navigation
      startVoiceNavigation(route);
    }

    function startVoiceNavigation(routeCoords) {
      if (!navigator.geolocation) {
        statusDiv.innerText = "GPS not supported.";
        return;
      }

      let currentStep = 0;
      const spoken = new Set();

      function say(text) {
        if (spoken.has(text)) return;
        spoken.add(text);
        const msg = new SpeechSynthesisUtterance(text);
        speechSynthesis.speak(msg);
      }

      function checkProximity(position) {
        const userLoc = [position.coords.latitude, position.coords.longitude];
        for (let i = currentStep; i < routeCoords.length; i++) {
          const dist = turf.distance(turf.point(userLoc), turf.point(routeCoords[i]), { units: 'miles' });
          if (dist < 0.05) {
            say(`Approaching waypoint ${i + 1}`);
            currentStep = i + 1;
            break;
          }
        }
      }

      navigator.geolocation.watchPosition(checkProximity, err => {
        statusDiv.innerText = "GPS error: " + err.message;
      }, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 10000
      });

      statusDiv.innerText = "Navigation started...";
    }

    buildFullRoute();
  </script>
</body>
</html>