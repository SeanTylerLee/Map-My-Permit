<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Permit Route Navigation</title>
  <link href="https://unpkg.com/leaflet/dist/leaflet.css" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css" />
  <style>
    #map { height: 65vh; margin-top: 10px; border-radius: 10px; }
    #routeInstructions, #debugLog {
      margin-top: 1rem;
      background: #eee;
      padding: 10px;
      border-radius: 8px;
      font-family: monospace;
      white-space: pre-wrap;
      max-height: 20vh;
      overflow-y: auto;
    }
    button {
      margin-top: 10px;
      width: 100%;
      padding: 12px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background-color: #007aff;
      color: white;
    }
    button:nth-of-type(2) {
      background-color: #34c759;
    }
  </style>
</head>
<body>
  <header><h1>Permit Route Navigation</h1></header>
  <main class="container">
    <div id="map"></div>
    <button id="viewRouteBtn">üëÅÔ∏è View Route</button>
    <button id="enableGPSBtn">üìç Re-enable GPS</button>
    <div id="routeInstructions">Route instructions will appear here...</div>
    <div id="debugLog">Debug log will appear here...</div>
  </main>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const MAPBOX_TOKEN = "pk.eyJ1Ijoic2VhbmxlZTkyIiwiYSI6ImNtZTAyeG0wbzAwamgybHE2cmwzenJtM2cifQ.DE8FeoDvc3EzuyR5uPopzA";
    const routeSegments = JSON.parse(localStorage.getItem("parsedRouteSegments") || "[]");
    const selectedState = localStorage.getItem("routeState") || "";
    const manualStart = JSON.parse(localStorage.getItem("manualStart") || "null");
    const manualEnd = JSON.parse(localStorage.getItem("manualEnd") || "null");
    const instructionBox = document.getElementById("routeInstructions");
    const debugBox = document.getElementById("debugLog");

    const stateBBoxes = {
      "Wyoming": "-111.05,40.99,-104.05,45.00",
      "Texas": "-106.65,25.84,-93.51,36.5",
      "Oklahoma": "-103.0,33.6,-94.4,37.0",
      "Kansas": "-102.1,36.9,-94.6,40.0",
      "Colorado": "-109.1,36.9,-102.0,41.0",
      "Nebraska": "-104.05,39.99,-95.3,43.0"
    };

    let gpsCentering = true;
    document.getElementById('viewRouteBtn').onclick = () => {
      gpsCentering = false;
      alert("GPS auto-centering disabled.");
    };
    document.getElementById('enableGPSBtn').onclick = () => {
      gpsCentering = true;
      alert("GPS auto-centering re-enabled.");
    };

    const map = L.map('map').setView([43.0, -106.0], 6);
    L.tileLayer(`https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, {
      maxZoom: 18, tileSize: 512, zoomOffset: -1,
      attribution: '&copy; <a href="https://www.mapbox.com/">Mapbox</a>'
    }).addTo(map);

    function isValidRoadName(road) {
      return road && /^(I|US|WY|SR|FM|CR|BUS)[-\s]?\d+/i.test(road);
    }

    async function geocodePlace(label) {
      const bbox = stateBBoxes[selectedState] || "";
      const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(label + ", " + selectedState)}.json?access_token=${MAPBOX_TOKEN}&bbox=${bbox}`;
      const res = await fetch(url);
      const data = await res.json();
      if (data.features?.length > 0) {
        const [lon, lat] = data.features[0].center;
        return { lat, lng: lon };
      }
      return null;
    }

    function distance(a, b) {
      const R = 6371e3;
      const œÜ1 = a.lat * Math.PI / 180;
      const œÜ2 = b.lat * Math.PI / 180;
      const ŒîœÜ = (b.lat - a.lat) * Math.PI / 180;
      const ŒîŒª = (b.lng - a.lng) * Math.PI / 180;
      const x = Math.sin(ŒîœÜ / 2) ** 2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(x), Math.sqrt(1 - x));
    }

    async function buildRoute() {
      if (!manualStart || !manualEnd) {
        alert("Start or end not set. Please select them on the map.");
        return;
      }

      const debugLogs = [];
      const waypoints = [];
      const instructions = [];

      const segmentCoords = [];

      for (const seg of routeSegments.filter(s => isValidRoadName(s.road))) {
        const from = await geocodePlace(seg.from);
        const to = await geocodePlace(seg.to);
        if (from && to) {
          segmentCoords.push({ seg, from, to });
        } else {
          debugLogs.push(`‚ùå Skipped (bad geocode): ${seg.road} ${seg.from} ‚Üí ${seg.to}`);
        }
      }

      // Only keep segments that fall between manualStart and manualEnd
      const filtered = segmentCoords.filter(({ from, to }) => {
        const mid = {
          lat: (from.lat + to.lat) / 2,
          lng: (from.lng + to.lng) / 2
        };
        const dStart = distance(manualStart, mid);
        const dEnd = distance(manualEnd, mid);
        const total = distance(manualStart, manualEnd);
        return dStart + dEnd <= total * 1.2; // allow ~20% margin
      });

      if (filtered.length === 0) {
        debugBox.textContent = "‚ùå No segments found between start and end.";
        return;
      }

      for (const { seg, from, to } of filtered) {
        const coords = `${from.lng},${from.lat};${to.lng},${to.lat}`;
        const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${coords}?geometries=geojson&steps=true&access_token=${MAPBOX_TOKEN}`;
        const res = await fetch(url);
        const data = await res.json();

        if (data.routes?.length) {
          const route = data.routes[0];
          const latlngs = route.geometry.coordinates.map(([lng, lat]) => [lat, lng]);
          L.polyline(latlngs, { color: 'blue', weight: 5 }).addTo(map);
          waypoints.push(from, to);
          route.legs[0].steps.forEach(step => instructions.push(step.maneuver.instruction));
          debugLogs.push(`‚úÖ Routed: ${seg.road} ${seg.from} ‚Üí ${seg.to}`);
        } else {
          debugLogs.push(`‚ùå Routing failed: ${seg.road} ${seg.from} ‚Üí ${seg.to}`);
        }
      }

      if (waypoints.length < 2) {
        debugBox.textContent = "‚ùå Not enough good segments.";
        return;
      }

      instructionBox.textContent = instructions.join("\n");
      debugBox.textContent = debugLogs.join("\n");

      const allPoints = waypoints.map(p => [p.lat, p.lng]);
      map.fitBounds(L.polyline(allPoints).getBounds());

      // GPS & voice
      let spokenSet = new Set();
      function speak(text) {
        if (!('speechSynthesis' in window)) return;
        const utter = new SpeechSynthesisUtterance(text);
        speechSynthesis.speak(utter);
      }

      if ('geolocation' in navigator) {
        navigator.geolocation.watchPosition(
          (pos) => {
            const { latitude, longitude } = pos.coords;
            if (window.gpsMarker) map.removeLayer(window.gpsMarker);
            window.gpsMarker = L.circleMarker([latitude, longitude], {
              radius: 6, color: 'green', fillColor: 'lime', fillOpacity: 1
            }).addTo(map);

            if (gpsCentering) {
              map.setView([latitude, longitude], 15);
            }
          },
          (err) => console.warn("GPS error:", err),
          { enableHighAccuracy: true, maximumAge: 5000 }
        );
      }
    }

    buildRoute();
  </script>
</body>
</html>